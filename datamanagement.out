\BOOKMARK [1][-]{section.1}{Redundancy}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{Write a program \(C,C++, R or Python\), which produces four striped data and one parity file as described above using the given input file.}{section.1}% 2
\BOOKMARK [2][-]{subsection.1.2}{Extend the program to compute additionally the parity of all bytes within one stripe file.}{section.1}% 3
\BOOKMARK [2][-]{subsection.1.3}{1.3 What is the 5-byte parity value if you write it it in hexadecimal format like P\1365 =0x[q0][q1][q2][q3][q4], where the [qx] are the hexadecimal parity bytes computed by xor-ing all bytes in each stripe file.}{section.1}% 4
\BOOKMARK [2][-]{subsection.1.4}{If you create a sixth stripe file, which contains the row-wise parities of the five stripe files, what would be the contents of this file?}{section.1}% 5
\BOOKMARK [2][-]{subsection.1.5}{1.5 After some time you recompute the 5-byte parity value as in 1.3. Now the result is P\1365 = 0x a5 07 a0 01 9e. Something has been corrupted. You want to reconstruct the original file raid4.input using the 5 stripe files.}{section.1}% 6
\BOOKMARK [1][-]{section.2}{Cryptography}{}% 7
\BOOKMARK [2][-]{subsection.2.1}{Is this symmetric or asymmetric encryption and explain why?}{section.2}% 8
\BOOKMARK [2][-]{subsection.2.2}{Write a small brute force program which tests keys from 0..255 and use a dictionary approach to figure out the original message.}{section.2}% 9
\BOOKMARK [1][-]{section.3}{Object Storage}{}% 10
\BOOKMARK [2][-]{subsection.3.1}{Write a program in Python, R or using ROOT, which simulates the placement of 10GB files to random locations and account the used space on each hard disk. Once the first hard disk is full, you stop to place files.}{section.3}% 11
\BOOKMARK [3][-]{subsubsection.3.1.1}{How many files did you manage to place?}{subsection.3.1}% 12
\BOOKMARK [3][-]{subsubsection.3.1.2}{What is the percentage of total used space on all hard disks in the moment the first disk is full?}{subsection.3.1}% 13
\BOOKMARK [2][-]{subsection.3.2}{Repeat the same task placing 1GB files until the first hard disk is full.}{section.3}% 14
\BOOKMARK [3][-]{subsubsection.3.2.1}{How many files did you manage to place?}{subsection.3.2}% 15
\BOOKMARK [3][-]{subsubsection.3.2.2}{What is the percentage of total used space on all hard disks in the moment the first disk is full?}{subsection.3.2}% 16
\BOOKMARK [2][-]{subsection.3.3}{Based on this observation: why do you think object storage typically stores fixed size blocks of 4M and not files of GBs size as a whole? \(so called block storage approach\)}{section.3}% 17
\BOOKMARK [2][-]{subsection.3.4}{Compute the average used space on all hard disks and the standard deviation for the average used space for 10 GB and 1GB and 4M files. How is the standard deviation correlated to the block size and why? If we now repeat such an experiment for many more \(thousands\) of hard disks, which kind of distribution do you get when you do a histogram of the used space of all hard disks?}{section.3}% 18
\BOOKMARK [1][-]{section.4}{Rest APIs \046 Block Chain Technology}{}% 19
\BOOKMARK [2][-]{subsection.4.1}{Rest API transactions}{section.4}% 20
\BOOKMARK [3][-]{subsubsection.4.1.1}{Use the REST API and the curl command to transfer coins of the genesis or any other account on your own team account.}{subsection.4.1}% 21
\BOOKMARK [3][-]{subsubsection.4.1.2}{What is the maximum number of transactions one given team can add to the Block Chain in one day?}{subsection.4.1}% 22
\BOOKMARK [2][-]{subsection.4.2}{The server has a function to compute a hash of a block in the Block Chain:}{section.4}% 23
\BOOKMARK [3][-]{subsubsection.4.2.1}{Explain what this function does and why is this `the key' for Block Chain technology?}{subsection.4.2}% 24
\BOOKMARK [3][-]{subsubsection.4.2.2}{If you have the knowledge of the hash function, how can you validate the contents of the Block Chain you received using a GET request to make sure, nobody has tampered with it? You don't need to implement it! Explain the algorithm to validate a Block Chain!}{subsection.4.2}% 25
\BOOKMARK [3][-]{subsubsection.4.2.3}{Why might the GET REST API run into scalability problems?}{subsection.4.2}% 26
\BOOKMARK [3][-]{subsubsection.4.2.4}{If the Crypto server goes down, the way it is implemented it loses the current account balances. How can the server recompute the account balances after a restart from the saved Block Chain?}{subsection.4.2}% 27
\BOOKMARK [3][-]{subsubsection.4.2.5}{What are the advantages of using a REST API and JSON in a client-server architecture? What are possible disadvantages?}{subsection.4.2}% 28
\BOOKMARK [1][-]{section.5}{Appendix}{}% 29
\BOOKMARK [2][-]{subsection.5.1}{4}{section.5}% 30
